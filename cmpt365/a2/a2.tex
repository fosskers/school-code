\documentclass{article}
% GENERAL
\usepackage{setspace,mathtools,amsfonts,amsmath,amsthm,amssymb,hyperref}
\usepackage{tikz,epigraph,pgfplots}  % For trees
\usepackage[utf8]{inputenc}
\usepackage{tikz-qtree,tikz-qtree-compat}
\usepackage{forest}

% FONT
\usepackage{arev}
\usepackage[T1]{fontenc}

% FOR SOURCE CODE
\usepackage{listings}
\lstset{frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=4
}

% MARGINS
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}
\onehalfspacing

\begin{document}
\title{CMPT 365 - Assignment 2 : JPEG Compression}
\author{Colin Woodbury\\ 301238755\\ cwoodbur@sfu.ca}
\date{\today}
\maketitle

% --- TABLE OF CONTENTS ---
\tableofcontents
\clearpage
% -------------------------

\section{Motivation}
JPEG is an undeniable standard in the computing world, and it employs
some interesting mathematics that warrent careful study. This project
was an excellent opportunity to write a small, useful library that
someone might find useful, if not just for educational purposes. I named
the library \emph{peggy}.

\section{Tool Choice}
\subsection{Haskell}
Haskell was the clear language choice for me, as it is my primary language.
It has an active community and a very robust set of 3rd-party packages,
and it allows me to code the quickest with the fewest headaches. The
entire \emph{peggy} library I produced is only about 250 lines including
comments and module headers.

\subsection{JuicyPixels}
\href{http://hackage.haskell.org/package/JuicyPixels-3.2.7}{JuicyPixels}
is an image manipulation library for Haskell. I used it only for initial
input and output of jpeg data, so that I could test on real jpegs.

\subsection{Matrices}
After testing out a number of linear algebra libraries
(\href{https://github.com/fosskers/playground/tree/master/haskell/eigen}{here}, \href{https://github.com/fosskers/playground/tree/master/haskell/linear}{here} and \href{https://github.com/fosskers/playground/tree/master/haskell/matrices}{here}), I settled on the
\href{http://hackage.haskell.org/package/matrices}{matrices} package.
It is written in native Haskell (with no binding to lower C libraries, etc.),
and allowed for two key operatations:

\begin{itemize}
\item Submatrices for both truncating a non-8x8 image to a nicer size, and
  for block splitting during compression.
  Example: Given some \emph{Matrix} m, \fbox{subMatrix (0,0) (5,5) m}
\item Reparation of split 8x8 submatrices to form the original Channel matrix.
\end{itemize}

This library was nice to use, but as we will see below in the \emph{Failures}
section, it may have been the cause of some issues.

\section{Methods}
\subsection{Phantom Typing}
I leveraged \emph{Phantom Typing} in Haskell to ensure type-safety
when manipulating the various channels.

\begin{lstlisting}
-- | A Jpeg has a height and width, and three colour channels from the
-- YCbCr colour space.
data Jpeg = Jpeg { _width :: !Int
                 , _height :: !Int
                 , _y' :: Chan Y  Int
                 , _cb :: Chan Cb Int
                 , _cr :: Chan Cr Int } deriving (Eq,Show)

-- | A channel is a matrix of pixel values, not constrained to any
-- particular `Num` type. @c@ is a phantom parameter for indicating
-- the specific Channel type.
newtype Chan c a = Chan { _mat :: Matrix a } deriving (Eq,Show)
  
\end{lstlisting}

Notice the \emph{c} parameter in the \emph{Chan} newtype is not used in
the actual data definition. This allowed me to define functions like
\emph{toR} that recovers an RGB \emph{R} channel from type-guaranteed
Y and Cr channels:

\begin{lstlisting}
-- | Recover the R Channel.
toR :: Chan Y Int -> Chan Cr Int -> Chan R Int
toR (_mat -> y) (_mat -> cr) = Chan $ M.zipWith (\a b -> a + b) y cr'
  where cr' = M.map (\n -> round $ 1.403 * (fi n - 128)) cr
\end{lstlisting}

\subsection{Lenses}
\emph{lens} is a well-known library in the Haskell world for manipulating
nested data structures in a pure functional way. Splitting a channel
into a List-of-Lists of 8x8 subchannels was a simple as:

\begin{lstlisting}
-- | Convert a Channel into a List-of-Lists of 8x8 subchannels.
blocks :: Chan a Int -> [[Chan a Int]]
blocks (_mat -> c) = (indexes $ dim c) & each . each %~ Chan . f
  where f (i,j) = M.subMatrix (i,j) (i+7,j+7) c

-- | The starting indices of every 8x8 subchannel within a parent channel's
-- inner `Matrix`.
indexes :: (Int,Int) -> [[(Int,Int)]]
indexes (w,h) = groupBy (\(a,_) (b,_) -> a == b) is
  where is = (,) <$> [0,8..w-8] <*> [0,8..h-8]  
\end{lstlisting}

The \fbox{\ldots \& each . each \%\~{} \ldots} construction allows us
to apply some pure function to the List-of-Lists nested structure
given by the \emph{indexes} function.

\subsection{Testing Suite}
I utilized the \emph{tasty} library for unit tests.
My compress-decompression isomorphism produces the same results
as the example on the JPEG Wikipedia page.

\section{Results}
\subsection{Successes}
With a quantization matrix that yields 50\% quality, we see:

\begin{center}
  \includegraphics[scale=2]{mtn-square}
  \includegraphics[scale=0.5]{new-mtn-square}
\end{center}

\begin{center}
  \includegraphics[scale=2.5]{dots}
  \includegraphics[scale=2]{new-dots}
\end{center}

We see some artifacts, but the difference in overall quality is minimal.
With the mountain image, we see a size reduction of 132kb to 64kb.

\subsection{Failures}
Something in either my library or JuicyPixels causes violent skewing for
\emph{all} non-square images, and even some square ones. For instance:

\begin{center}
  \includegraphics[scale=0.5]{small-kitten}
\end{center}

This is the original image.

\begin{center}
  \includegraphics[scale=0.5]{03}
\end{center}

This is the image \emph{only} converted from a JuicyPixels image type
to my own and back.

\begin{center}
  \includegraphics[scale=0.5]{02}
\end{center}

This is the image after applying my compression and decompression functions,
then reoutputing it with JuicyPixels. Notice that the skewing is even
worse here.

Strangely, this skewing doesn't occur if I convert-then-deconvert
(no compression) a square image:

\begin{center}
  \includegraphics[scale=0.5]{windows}
  \includegraphics[scale=0.4]{orig-windows}
\end{center}

Left: original. Right: Converted-then-back.

But, just as oddly and unlike the mountain, this square image \emph{does}
get skewed when I apply the compression isomorphism:

\begin{center}
  \includegraphics[scale=0.5]{new-windows}
\end{center}

The solution to which, after many hours of debugging, I have yet
to discover.

Possibilities:

\begin{itemize}
\item Some JPEGs have strange hidden buffer data that my algorithms
  don't account for
\item My algorithm is wrong, despite my units test all working
\item The \emph{matrices} library has bugs
\end{itemize}

Update: After a few more hours of debugging, I've determined what conditions
will guarantee what result.

\begin{itemize}
\item If an image is square, and its dimensions are a multiple of 8,
  then the image will succeed to compress/decompress, and won't skew. Note
  that no truncation is performed for these images.
\item If an image is square, but not a multiple of 8x8, then it
  will skew only during the compression/decompression process.
\item If an image is rectangular, it will skew once during type conversion,
  and \emph{again} during compression.
\end{itemize}

Thus, there are two locations where skewing is happening. One is within
my two type conversion functions, and the other is elsewhere. However,
I cannot pinpoint the exact problem, to the point where I am beginning to
suspect a bug in the \emph{matrices} library. Doubting one's library is
a last resort, but I'm left with little else, given that all of my unit
tests and other manual tests of \emph{matrices} functionality succeed.

\end{document}
